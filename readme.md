новая неуниверсальная, но более стройная схема
1. совершенно пустой интерфейс "участник", чтобы создать массив участников и чтобы передавать "участника" в  "препятствие"
2. интерфейс "умеющий бегать" наследует "участника". в нем только один метод "получить ограничение по бегу"
3. остальные интерфейсы "умеющие..." по числу действий: прыгать, плавать и т.п.
4. интерфейс "препятствие" с одним методом "преодолеть", которому передается "участник"
5. классы "стена", "дорожка", бассейн и т.п. - реализуют интерфейс "препятствие". в его методе "преодолеть" мы сначала проверяем, может ли "участник" бегать и т.п. через instanceof. если нет - переходим к следующему "препятствию", для чего вернем истину. иначе получаем "ограничение по действию" через приведение к "умеющий бегать". проверяем, если длина "препятствия" больше возможности - ругаемся и возвращаем ложь,    чтобы прервать дальнейшее прохождение. иначе хвалимся и возвращаем истину
6. классы "человек", "кот", "робот" - реализуют только те интерфейсы, которые нужны. например, робот не умеет плавать. конечно, придется каждому классу прописать лимиты для для каждого действия и инициализировать их в конструкторе, но это "меньшее зло"
7. в мейне создаем два массива, перебираем второй внутри первого, вызываем "преодолеть", передавая "препятствию" "участника". если вернулась ложь, прерываем прохождение массива "препятствий", переходим к следующему "участнику"
таким образом, классы типа независимы друг от друга, все ссылки косвенные, через интерфейсы "действий"